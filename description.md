
#### Инструменты: Qt(C++), OpenCV

## Описание алгоритма:

Процесс построен на сравнении двух изображений: до стрельбы и после стрельбы.
Оба изображения проходят через предобработку. 
Предобработка включает в себя медианную фильтрацию и бинаризацию.

Медианная фильтрация выполнена с матрицей на 7:
  
    cv::medianBlur(second_mat,second_mat,7);

Бинаризация выполнена через алгоритм Отсу. Порог бинаризаций можно задать:

    cv::threshold(gray,bin,ui->treshhold->value(),255,cv::THRESH_OTSU);

После происходит вычитания второго изображения из первого:
    
    cv::subtract(second_bin,first_bin,res_sub);

В результате этой операции получаем отличия изображений, что можно прировнять к местам попадания. Отличия возможны и за пределами мишеней и это надо учитывать.
Для этого найдем все окружности на изображении и обведем их:

    cv::HoughCircles(gray,circles,cv::HOUGH_GRADIENT,1,gray.rows/16, 100, 30,5,70 );
    for( size_t i = 0; i < circles.size(); i++ )
    {
        cv::Vec3i c = circles[i];
        cv::Point center = cv::Point(c[0], c[1]);
        int radius = c[2];
        circle(res_sub, center, radius, cv::Scalar(255,255,255), 2, cv::LINE_AA);
    }

Затем, на основе первого изображения и результата вычитания с обведенными мишенями формируем результирующее изображения:

    for(int j = 0; j <_img.height(); j++)
    {
        for(int i = 0; i <_img.width(); i++)
        {
            for(size_t k = 0; k < circles.size(); k++)
            {
                int radius = circles[k][2];
                int x = circles[k][0] - radius;
                int y = circles[k][1] - radius;
                x = x < 0 ? 0 : x;
                y = y < 0 ? 0 : y;
                if((i >= x && i <= x + radius*2 && j >= y && j <= y + radius*2) && qGray(temp_img.pixel(i,j)) == 255)
                {
                    _img.setPixel(i,j,temp_img.pixel(i,j));
                    break;
                }
                else
                {
                    _img.setPixel(i,j,_drawed.pixel(i,j));
                }
            }
        }
    }
  
Проходим по всему изображению. Если мы находимся в пределах одной из мишеней и результат вычитания в этой точке равен 255(белый), то записываем результат вычитания. В противном случае записываем в результат исходное первое изображение.
В результате получим первое изображение, с нанесенными на него результатами вычитания двух изображений. При этом изменения перенесутся только в пределах мишеней.

## Описание интерфейса:

### Главное окно:

Кнопка «первое изображение»: сохранить первое изображение

Кнопка «второе изображение»: сохранить второе изображение

Кнопка «обработка»: начало работы алгоритма

Порог бинаризации: значение, которое будет учитываться при предобработке

Кнопка «Выбрать»: выбрать изображение из проводника

Линия ввода: путь к видео

Кнопка «Старт видео»: начать проигрывание видео

Кнопка «Видео с камеры»: начать трансляцию с камеры

Счетчик справа от кнопки «Видео с камеры»: Индекс камеры в системе

Доп. Задержка: значение дополнительной задержки при проигрывании видео в миллисекундах

Кнопка «Стоп»: остановить проигрывание видео или трансляцию с камеры


### Окно «Изображения»:

Первое изображение: исходное первое изображение

Второе изображение: исходное второе изображение

Третье изображение: предобработанное первое изображение

Четвертое изображение: предобработанное второе изображение


Примечание: если изображение отрисовывается не полностью, то откройте окно полностью и нажмите «обработка» еще раз.

### Окно «Результат»:

Результат обработки алгоритма

Примечание: если изображение отрисовывается не полностью, то откройте окно полностью и нажмите «обработка» еще раз.

Окно «Отрисовка»:

Позволяет нарисовать дополнительные окружности(доп мишени)

Радиус: радиус окружности

Кнопка «Отмена»:Отменить последнее изменение
